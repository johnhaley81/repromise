<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Interop · Repromise</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Representation"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Interop · Repromise"/><meta property="og:type" content="website"/><meta property="og:url" content="https://aantron.github.io/repromise/repromise/index.html"/><meta property="og:description" content="## Representation"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/repromise/undefined"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="stylesheet" href="/repromise/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/repromise/"><h2 class="headerTitle">Repromise</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/repromise/docs/QuickStart" target="_self">Docs</a></li><li class="siteNavGroupActive"><a href="/repromise/docs/API" target="_self">API</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/aantron/repromise" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Reference</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul><li class="navListItem"><a class="navItem" href="/repromise/docs/WhatWhy">What &amp; Why</a></li><li class="navListItem"><a class="navItem" href="/repromise/docs/QuickStart">Quick Start</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Reference</h3><ul><li class="navListItem"><a class="navItem" href="/repromise/docs/API">API</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/repromise/docs/Interop">Interop</a></li><li class="navListItem"><a class="navItem" href="/repromise/docs/RejectableAPI">Rejectable API</a></li><li class="navListItem"><a class="navItem" href="/repromise/docs/DesignFAQ">Design FAQ</a></li><li class="navListItem"><a class="navItem" href="/repromise/docs/Performance">Performance</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/aantron/repromise/tree/master/doc/docs/interop.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Interop</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="representation"></a><a href="#representation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Representation</h2>
<p>Repromise is built for maximum interop with JS promises. In fact, Repromises are ordinary JS <code>Promise</code>s at runtime:</p>
<pre><code class="hljs css languages- reason">Repromise.resolve(<span class="hljs-number">1</span>) |&gt; Js.<span class="hljs-built_in">log</span>;
<span class="hljs-comment">/* Promise { 1 } */</span>

Js.Promise.resolve(<span class="hljs-number">1</span>) |&gt; Js.<span class="hljs-built_in">log</span>;
<span class="hljs-comment">/* Promise { 1 } */</span>
</code></pre>
<p>The one exception is when nesting promises. In JS, nesting is not possible at all, because nested promises collapse:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">Js</span>.Promise.resolve(<span class="hljs-keyword">Js</span>.Promise.resolve(<span class="hljs-number">1</span>)) |&gt; <span class="hljs-keyword">Js</span>.log<span class="hljs-comment">;</span>
/* Promise { <span class="hljs-number">1</span> } */
</code></pre>
<p>If not for collapsing, we would expect two levels of <code>Promise</code> here: <code>Promise { Promise { 1 } }</code>. But the two <code>Promise</code>s have been flattened into one. This makes it impossible to give a sound typing to ordinary JS promises. So, to prevent collapse, Repromise inserts a wrapper object:</p>
<pre><code class="hljs css languages- reason">Repromise.resolve(Repromise.resolve(<span class="hljs-number">1</span>)) |&gt; Js.log;
/* Promise { WrappedRepromise { wrapped: Promise { <span class="hljs-number">1</span> } } } */
</code></pre>
<p>Repromise functions (such as <a href="API#wait"><code>wait</code></a> and <a href="API#then"><code>then_</code></a>) silently insert and remove this wrapper object, as needed.</p>
<h3><a class="anchor" aria-hidden="true" id="takeaway"></a><a href="#takeaway" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Takeaway</h3>
<p>The most important takeaway from this is that in all cases that are possible in JS, Repromises have exactly the same representation.</p>
<p>Repromise just adds one more case, that cannot be generated by JS code, but can be generated on the Reason side by Repromise code, and that is the case of nested Repromises with a wrapper object in between them to prevent collapse.</p>
<p><br/></p>
<h2><a class="anchor" aria-hidden="true" id="creating-a-binding"></a><a href="#creating-a-binding" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a binding</h2>
<p>So, any JS function that returns a promise already returns a valid Repromise. Let's use this to write a binding to <a href="https://www.npmjs.com/package/node-fetch"><code>node-fetch</code></a>:</p>
<pre><code class="hljs"><span class="hljs-keyword">type</span> response;

[@bs.<span class="hljs-keyword">module</span>]
<span class="hljs-keyword">external</span> fetch: <span class="hljs-built_in">string</span> =&gt; <span class="hljs-type">Repromise</span>.t(response) = <span class="hljs-string">"node-fetch"</span>;

[@bs.send]
<span class="hljs-keyword">external</span> text: response =&gt; <span class="hljs-type">Repromise</span>.t(<span class="hljs-built_in">string</span>) = <span class="hljs-string">""</span>;
</code></pre>
<p>We can test it with:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">let</span> url =
  <span class="hljs-string">"https://raw.githubusercontent.com/"</span>
  ++ <span class="hljs-string">"aantron/repromise-example-bsb/master/main.re"</span>;

<span class="hljs-keyword">let</span> () =
  fetch(url)
  |<span class="hljs-type">&gt; Repromise</span>.then_(text)
  |<span class="hljs-type">&gt; Repromise</span>.wait(Js.log);
</code></pre>
<p>This downloads and prints <code>main.re</code> from the <a href="https://github.com/aantron/repromise-example-bsb">Repromise example repo</a>.</p>
<p>A complete version of the above example, with all boilerplate, is in the <a href="https://github.com/aantron/repromise-example-binding">binding example repo</a>.</p>
<p><br/></p>
<h2><a class="anchor" aria-hidden="true" id="promises-resolved-with-multiple-types"></a><a href="#promises-resolved-with-multiple-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promises resolved with multiple types</h2>
<p>Some JS APIs may resolve promises with values of different types, taking advantage of the dynamic &quot;typing&quot; of JS. In such cases, you can do this:</p>
<pre><code class="hljs css languages- reason">/* <span class="hljs-type">An</span> abstract <span class="hljs-keyword">type</span> <span class="hljs-keyword">for</span> the promise <span class="hljs-keyword">value</span>. */
<span class="hljs-keyword">type</span> stringOrInt;

/* <span class="hljs-type">Use</span> the abstract <span class="hljs-keyword">type</span> <span class="hljs-keyword">to</span> write the binding. */
[@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">external</span> foo: <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-type">Repromise</span>.t(stringOrInt) = <span class="hljs-string">""</span>;

/* <span class="hljs-type">Neither</span> the abstract <span class="hljs-keyword">type</span>, nor the binding foo, should be exposed <span class="hljs-keyword">to</span> the
   users (that is, <span class="hljs-keyword">in</span> the .rei <span class="hljs-keyword">for</span> the binding). <span class="hljs-type">Instead</span>, wrap foo <span class="hljs-keyword">in</span> a
   <span class="hljs-keyword">function</span> that checks the <span class="hljs-keyword">type</span>, <span class="hljs-keyword">and</span> converts all the possibilities <span class="hljs-keyword">to</span>
   values <span class="hljs-keyword">of</span> one <span class="hljs-keyword">type</span>. <span class="hljs-type">In</span> this case, we will use a variant: */
<span class="hljs-keyword">let</span> foo = <span class="hljs-literal">()</span> =&gt;
  foo<span class="hljs-literal">()</span>
  |&gt; <span class="hljs-type">Repromise</span>.map(<span class="hljs-keyword">value</span> =&gt;
    switch (<span class="hljs-type">Js</span>.<span class="hljs-type">Types</span>.reify_type(<span class="hljs-keyword">value</span>)) {
    | (<span class="hljs-type">Js</span>.<span class="hljs-type">Types</span>.<span class="hljs-type">String</span>, s) =&gt; <span class="hljs-type">`String</span>(s)
    | (<span class="hljs-type">Js</span>.<span class="hljs-type">Types</span>.<span class="hljs-type">Int</span>, i) =&gt; <span class="hljs-type">`Int</span>(i)
    | _ =&gt; <span class="hljs-keyword">assert</span>(<span class="hljs-literal">false</span>)
    });
</code></pre>
<p><br/></p>
<h2><a class="anchor" aria-hidden="true" id="rejection"></a><a href="#rejection" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rejection</h2>
<p>JS APIs often reject promises. To bind to these, you can use the <a href="RejectableAPI"><code>Repromise.Rejectable</code></a> API.</p>
<p>If the JS API rejects promises with rejections of only one type, you can use that type directly in the binding. In the made-up example below, the rejection type is <code>string</code>:</p>
<pre><code class="hljs css languages- reason">[@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">external</span> foo: <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-type">Repromise</span>.<span class="hljs-type">Rejectable</span>.t(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>) = <span class="hljs-string">""</span>;
</code></pre>
<p>Rejectable Repromises should not be exposed to users of bindings. Instead, rejections should be converted into explicit error handling (often <a href="https://bucklescript.github.io/bucklescript/api/Belt.Result.html"><code>Belt.Result</code></a>) using <a href="RejectableAPI#catch"><code>Repromise.Rejectable.catch</code></a>:</p>
<pre><code class="hljs css languages- reason">[@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">external</span> foo: <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-type">Repromise</span>.<span class="hljs-type">Rejectable</span>.t(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>) = <span class="hljs-string">""</span>;

<span class="hljs-keyword">let</span> foo = <span class="hljs-literal">()</span> =&gt;
  foo<span class="hljs-literal">()</span>
  |&gt; <span class="hljs-type">Repromise</span>.<span class="hljs-type">Rejectable</span>.map(<span class="hljs-keyword">value</span> =&gt;
    <span class="hljs-type">Belt</span>.<span class="hljs-type">Result</span>.<span class="hljs-type">Ok</span>(<span class="hljs-keyword">value</span>))
  |&gt; <span class="hljs-type">Repromise</span>.<span class="hljs-type">Rejectable</span>.catch(error =&gt;
    <span class="hljs-type">Repromise</span>.resolve(<span class="hljs-type">Belt</span>.<span class="hljs-type">Result</span>.<span class="hljs-type">Error</span>(error)))
/* <span class="hljs-type">The</span> final promise has <span class="hljs-keyword">type</span> <span class="hljs-type">Repromise</span>.t(<span class="hljs-type">Belt</span>.<span class="hljs-type">Result</span>.t(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>)) */
</code></pre>
<p>Please let us know what helpers should be added to Repromise, to make these conversions easier.</p>
<p>If the JS API can reject with values of multiple JS types, this can be handled as in <a href="#promises-resolved-with-multiple-types">Promises resolved with multiple types</a>, except that the <code>Js.Types.reify_type</code> call should be placed into <code>catch</code> instead of <code>map</code>.</p>
<p><br/></p>
<h2><a class="anchor" aria-hidden="true" id="passing-promises-to-js"></a><a href="#passing-promises-to-js" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Passing promises to JS</h2>
<p>In most cases, binding to JS APIs that take promises as arguments works as one might expect:</p>
<pre><code class="hljs css languages- reason">[@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">external</span> foo: <span class="hljs-type">Repromise</span>.t(<span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span>;
</code></pre>
<p>JS APIs should never ask for nested promises, because JS promises don't support nesting anyway. So, we don't expect that there will be a JS API that needs a type signature like this:</p>
<pre><code class="hljs css languages- reason">[@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">external</span> foo: <span class="hljs-type">Repromise</span>.t(<span class="hljs-type">Repromise</span>.t(<span class="hljs-built_in">int</span>)) =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span>;
</code></pre>
<p>However, there is the <a href="https://github.com/aantron/repromise/issues/8">possibility</a> of a JS API that can accept promises of any type:</p>
<pre><code class="hljs css languages- reason">[@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">external</span> foo: <span class="hljs-type">Repromise</span>.t(<span class="hljs-symbol">'a</span>) =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span>;
</code></pre>
<p>In this case, it will be possible to pass a nested Repromise to the JS API. Repromise can support this, but we ask that you please let us know if you run into such a JS API by an <a href="https://github.com/aantron/repromise/issues">opening an issue</a>. That way, we can design something appropriate for the case. What we suspect is that all such JS APIs will actually be promise-manipulation libraries, that will have to be reimplemented as helper libraries for Repromise, the same way Repromise is a reimplementation of JS <code>Promise</code> functions.</p>
<p><br/></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/repromise/docs/API">← API</a><a class="docs-next button" href="/repromise/docs/RejectableAPI">Rejectable API →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#representation">Representation</a><ul class="toc-headings"><li><a href="#takeaway">Takeaway</a></li></ul></li><li><a href="#creating-a-binding">Creating a binding</a></li><li><a href="#promises-resolved-with-multiple-types">Promises resolved with multiple types</a></li><li><a href="#rejection">Rejection</a></li><li><a href="#passing-promises-to-js">Passing promises to JS</a></li></ul></nav></div><span></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: 'e0a7347e16ff47590833503d435facf2',
                indexName: 'repromise',
                inputSelector: '#search_input_react'
              });
            </script></body></html>